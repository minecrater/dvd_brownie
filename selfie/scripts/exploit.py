"""
Solution Approach:

I started reviewing the SelfiePool contract. I quickly found the method "drainAllFunds"
very interesting as in practically performed the actions needed to complete the challenge.

This method has a modifier called "onlyGovernance" that restricts who can call this
function. In this case the only address allowed to call it it's the Governance Contract
(governanceAddress). This led me to start reviewing the "SimpleGovernance" contract.

SimpleGovernance implements a governance mechanism. A super simplified explanation of
what this means is that this contract implements a series of rules to allow the queuing
and execution of actions that can have certain impact on something. In this specific
case in the SelfiePool.

The problem
-----------

So... How all of this can be interesting from an attacker's point of view?

Well, lets ignore all the details for now and asumme that an attacker is able to queue
an action and later execute it. This behavior could be leveraged to drain all the funds
of the SelfiePool just queuing the "drainAllFunds" action with the attacker's address
as the receiver. 

Let's review what the attacker needs to be able to do that.

The exploit
-----------

SimpleGovernance establishes that for a user to be able to propose an action it has
to have enough votes. This condition is checked by function "_hasEnoughVotes".

_hasEnoughVotes retrieves the caller's balance from the last snapshot (!) and establishes
that if that balance is higher than half the total supply of governance Tokens the caller
has enough votes to propose an action.

I then proceeded to check how the Snapshots worked.

Snapshots and who can take them
-------------------------------

Snapshots are implemented in DamnValuableTokenSnapshot. This contract inherits from
Open Zeppeling's [ERC20Snapshot](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Snapshot.sol)
I reviewed how Snapshots are taken and found the following interesting documentation
in the code:

* {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a
* set of accounts, for example using {AccessControl}, or it may be open to the public.
*

Then I checked how this was done in "DamnValuableTokenSnapshot".

I found function "Snapshot", code below:

   function snapshot() public returns (uint256) {
        lastSnapshotId = _snapshot();
        return lastSnapshotId;
    }

As you can see, function is public and can be called by anyone. Based on this the attack
path that an attacker can follow is:

1. A flash loan is triggered by an attacker asking for an amount of tokens that  will
allow it to have the required voting right.
2. When the loan is received, it then proceeds to taken an Snapshot
3. The borrowed money is returned
4. Having the snapshot taken in step 3 and considering that balances are calculated
based on Snapshots, it would be possible for the attacker to propose actions calling
function "queueAction".
5. Leveraging step 4, it will be possible to propose as action the execution of
function "drainAllFunds" by the SelfiePool.
6. After the action is proposed the attacker must wait ACTION_DELAY_IN_SECONDS before
executing the queued action
7. After ACTION_DELAY_IN_SECONDS passed the attacker can call "executeAction" and
execute action queued in step 5.

I implemented this attack in "AttackerContract".
"""
from brownie import chain
from web3 import Web3

TOKENS_IN_POOL = 1500000


def exploit(attacker_contract):
    attacker_contract.attack(Web3.toWei(TOKENS_IN_POOL, "ether"))

    # Advance days needed by Governance
    chain.sleep(60 * 60 * 24 * 2)

    attacker_contract.finishAttack()
