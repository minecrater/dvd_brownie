"""
The solution for this challenge is all in AttackerContract.sol

The path that I followed to solve the challenge was:

The main problem in my opinion is that the Pool does not distinguish who owns the
ethers deposited when verifying balances. If we look at the last assert in the
flashLoan function we can see that the contract uses "(this).balance". This balance
can be modified calling the "deposit" function.

Based on this the attack path could be:

1. An attacker asks for a flashLoan of X ethers.
2. It then proceeds to deposit the borrowed funds into the Lender Pool.
3. The flashLoan continues its execution and the final assert is verified.
4. As the attacker already deposited the funds (this).balance >= balanceBefore
5. But now, the Ether deposited by the attacker (the borrowed Ether) can be
withdrawed.

With this idea in mind I created attackerContract that performs these steps.

It asks for the Loan and uses the callback made by the LenderPool to deposit the
borrowed Ether. When the flash loan finishes, it withdraws the previously deposited
funds.
"""
