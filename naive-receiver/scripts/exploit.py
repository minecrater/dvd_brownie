"""
I solved this challenge in the following way. The contract provided,
"NaiveReceiverLenderPool" has a function called "flashLoan", that takes as parameters two
values: An Address (borrower) and an Integer (borrowAmount) that is how much will
be borrowed. The interesting (and potentially dangerous) behavior is that anyone can
specify and arbitrary address as borrower. When the function "flashLoan" is executed
the contract will try to execute a function called "receiveEther" assuming that the
address passed as borrower is a contract that has that function.

The aforementioned behavior, alone, won't present any immediate risks. However, in
this scenario, we are given a contract "FlashLoanReceiver" that acts as the receiver
of the borrowed amount. The problem relies in the fact that the function executed by
this contract "receiveEther" includes a logic to repay the borrow and also include
the fee asociated with the transaction (borrowing has a cost of 1 eth in this scenario).
This fee is paid to the pool:

...
uint256 amountToBeRepaid = msg.value + fee;
pool.sendValue(amountToBeRepaid);
...

Then, an attacker can invoke "flashLoan" in the "NaiveReceiverLenderPool", sending as
borrower the victim address. Doing this, it will trick the pool into calling the
function "receiveEther" in the "FlashLoanReceiver" contract, draining 1 Ether back to
the pool. This can be repeated N times. However, there is a better alternative to
perform this attack. If the attacker deploys a malicious contract (AttackerContract
in my case) the same attack can be performed just with one transaction. The attacker
contract will make N calls (messages) to the vulnerable contract.
"""

from brownie import accounts, AttackerContract

def exploit_multiple_calls(pool, receiver):
    for i in range(10):
        pool.flashLoan(receiver.address, '0.1 ether', {'from':accounts[1]})

def exploit_one_call(pool, victim):
    ac = AttackerContract.deploy(pool, victim, 10, {'from':accounts[1]})