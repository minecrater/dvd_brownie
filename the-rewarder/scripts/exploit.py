"""
Solution:

I started reviewing how the Contract in charge of paying rewards (TheRewarderPool)
worked. I found that it used the concept of snapshots to take "pictures" of the
balances that users have at certain point in time. This pool used the "AccountingToken"
for this purpose, but it is pegged 1:1 to the liquidity tokens, so for each liquidity
token deposited in the pool, a new AccountingToken is minted and for each liquidity
token withdrawed from the pool, the same number of AccoutingTokens is burned. I did
not find any problems with this so I continued looking.

I reviewed how these snapshots were taken and, more important, when. I found that
there is a private method "_recordSnapshot()" that triggers the snapshot mechanism.
This method is called by the Contract's constructor (not useful for an attacker) but
also from "distributeRewards" Public method!.

"distributeRewards" is the method used by the Rewarded Pool to pay the rewards to the
users who deposited the liquidity tokens and waited the required amount of time. This
method checks if it's time for a new rewards round (Line 71) and takes and snapshot.
After this it performs all calculations based on the balances of it. As this is a
public method anyone can call it. Having this in mind and based on the problem statement:

"But in the upcoming round, you must claim most rewards for yourself."

I started to see a potential attack path:

1. The attacker waits until the next rewards Round starts.
2. As soon as this happens asks for a flash Loan.
3. It deposits the Borrowed DVTs into the RewardPool.
4. It calls "distributeRewards". If he's the first to call it a new snapshot will be
taken, taking into account the deposited DVTs from the flash Loan!.
5. It receives the rewards (as the checks performed in TheRewarderPool's line 86
will pass, due to the fact that the attacker did not retrieve rewards before).
6. The attacker proceeds to withdraw the previously deposited DVTs to pay the flashLoan.
7. The attacker repays the Flash Loan.

Due to the way the Reward Pool calculates rewards, ie:

...
rewards = (amountDeposited * 100 * 10**18) / totalDeposits;
...

And considering the attacker borrowed and deposited 1.000.000 DVTs, in comparison with
what the other users have deposited (100 DVTs), practically, all rewards will go for
the attacker, as he deposited x1000 times more tokens than each user.

I developed this attack in the "AttackerContract" Contract.

"""

from brownie import AttackerContract, accounts


def exploit(liquidity_token, rewarder_pool, flash_loan_pool):
    attacker_address = accounts[2]

    attacker_contract = AttackerContract.deploy(
        liquidity_token, rewarder_pool, flash_loan_pool, {"from": attacker_address}
    )

    return attacker_contract, attacker_address
